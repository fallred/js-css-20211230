<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>无标题文档</title>
	<style type="text/css">
		#div1 {
			width: 500px;
			font-weight: bold;
			font-size: 24px;
			margin: 0 auto;
			height: 2em;
			background: #999;
		}
	</style>
</head>

<body>
	<div id="div1"></div>
</body>

</html>
<script>
	//工厂模式

	// function createPerson(name,age,job){
	//   var o=new Object();
	//   o.name=name;
	//   o.age=age;
	//   o.job=job;
	//   return o;
	// }
	// var person1=createPerson("zhangsan",19,"程序员");
	// var person2=createPerson("lisi",18,"教师");
	// console.log(person1.name);
	// console.log(person1.age);
	// console.log(person1.job);


	//构造函数模式
	// function Person(name,age,job){
	// 	this.name=name;
	// 	this.age=age;
	// 	this.job=job;
	// 	this.sayName=function(){
	// 		console.log(this.name);
	// 	}
	// }
	// var person1=new Person("zhangsan",19,"程序员");
	// var person2=new Person("lisi",18,"教师");
	// person1.sayName();



	//原型式继承
	// function object(o) {
	// 	function F() { }
	// 	F.prototype = o;
	// 	return new F();
	// }

	// var person = {
	// 	name: "Nicholas",
	// 	friends: ["Shellby", "Court", "Van"]
	// };
	// var anotherPerson = object(person);
	// anotherPerson.name = "Greg";
	// anotherPerson.friends.push("Rob");

	// var yetAnotherPerson = object(person);
	// yetAnotherPerson.name = "Linda";
	// yetAnotherPerson.friends.push("Barbie");

	// console.log(person.friends);


	

//ECMAScript5通过新增Object.create()规范化了原型式继承
	/*
	  var person={
			name:"Nicholas",
			friends:["Shellby","Court","Van"]
	  };
	var anotherPerson=Object.create(person);
	anotherPerson.name="Greg";
	anotherPerson.friends.push("Rob");
	
	var yetAnotherPerson=Object.create(person,{
		name:{value:"Linda"}
	});
	// yetAnotherPerson.name="Linda";
	yetAnotherPerson.friends.push("Barbie");
	console.log(yetAnotherPerson.name);
	console.log(person.friends);*/

//寄生式继承
	/*function createAnother(original){
		var clone=object(original);
		clone.sayHi=function(){
			console.log("hi");
		}
		return clone;
	}
	
	 var person={
			name:"Nicholas",
			friends:["Shellby","Court","Van"]
	  };
	var anotherPerson=createAnother(person);
	anotherPerson.sayHi();*/

//组合继承
	/*
	function SuperType(name){
	 this.name=name;
	}
	SuperType.prototype.sayName=function(){
		console.log(this.name);
	}
	function SubType(name,age){
	  SuperType.call(this,name);
	  this.age=age;
	}
	SubType.prototype=new SuperType();
	SubType.prototype.constructor=SubType;//增强对象
	SubType.prototype.sayAge=function(){
		console.log(this.age);
	}
	var instance=new SubType("zhangsan",19);
	instance.sayName();
	instance.sayAge();
	*/
//寄生式组合继承:通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
	/*
	function inheritPrototype(subType,superType){
	  var prototype=object(superType.prototype);//创建对象。创建超类型原型的一个副本，
	  prototype.constructor=subType;//增强对象。为创建的副本添加constructor属性，
	  subType.prototype=prototype;//指定对象
	}
	function SuperType(name){
	 this.name=name;
	 this.colors=["red","blue","green"];
	}
	SuperType.prototype.sayName=function(){
		console.log(this.name);
	}
	function SubType(name,age){
	  SuperType.call(this,name);
	  this.age=age;
	}
	inheritPrototype(SubType,SuperType);
	SubType.prototype.sayAge=function(){
		console.log(this.age);
	}
	var instance=new SubType("zhangsan",19);
	instance.sayName();
	instance.sayAge();*/
</script>