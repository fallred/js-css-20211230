<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>无标题文档</title>
</head>

<body>
</body>

</html>
<script>
  /*
   工厂模式不能解决实例识别
    构造函数解决实例识别问题
   原型模式解决构造函数不能复用问题
    
    每一个类天生就会有一个prototype原型属性: prototype是构造函数的属性（即构造函数的原型），这个属性是一个对象，保存复用的属性和方法
  
  
     __proro__是实例上的默认属性，指向构造函数的原型
      var person1=new FE360()的时候，person实例上的_proto_属性指向（person1是谁的实例就指向哪一个类）FE360的prototype属性，而这个属性又指向一个内存地址，这个内存地址里保存了这个类上prototype原型上的属性和方法
      
    类和函数其实没有很大区别，就是看你怎么用了
    如果Function f=new Function();这样这个Function就是一个类，并且这个类里的this指向当前实例
    如果直接Function()，那Function就是一个函数
  	
    类既可以是一个类，又可以是一个构造函数
  */
  function FE360(name, age) {
    this.name = name;
    this.age = age;
    this.a = 33;
    var a = 888;
  }
  FE360.prototype.writeJS = function () {
    console.log("我叫" + this.name + "我会写JS");
  }
  FE360.prototype.writeCSS = function () {
    console.log("我叫" + this.name + "我会写CSS");
  }
  FE360.prototype.a = "abc";
  var person1 = new FE360("路人甲", 26);
  var person2 = new FE360("路人乙", 36);
  // console.log(person1.writeCSS()==person2.writeCSS());
  // console.log(person2.a);
  // console.log(person2._proto_.a);
  person1.writeCSS();
  person1.writeJS();

  person2.writeCSS();
  person2.writeJS();
 /*
   console.log("windowa"+window.a);
   var a=1;
   function Fn1(){
     this.a=3;
     var a=2;
  }
  var fn2=new Fn1();
  Fn1();
  console.log(fn2.a);//3
  console.log(a);//3
  
  function inherit(p){
    if(p==null) throw TypeError();
    if(Object.create) return Object.create(p);
    var t=typeof p;
    if(t!="object"&&t!=='function')throw TypeError();
    function f(){};
    f.prototype=p;
    return new f();	 
  }*/
</script>